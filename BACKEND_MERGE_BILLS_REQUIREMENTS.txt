MERGE BILLS FEATURE - BACKEND REQUIREMENTS
=============================================

OVERVIEW
--------
Implement a comprehensive merge bills system that allows staff to merge multiple orders 
from the same table into a single order, split orders, and manage multi-order table scenarios.

CORE FEATURES
-------------
1. Merge multiple orders into one existing order
2. Merge multiple orders into a new combined order
3. Split a single order into multiple orders
4. View all active orders for a table
5. Track merge/split history
6. Handle customer information merging
7. Manage payment method conflicts

DATABASE SCHEMA UPDATES
=======================

1. ENHANCE ORDERS TABLE
-----------------------
ALTER TABLE orders ADD COLUMN order_group_id VARCHAR(255);
ALTER TABLE orders ADD COLUMN order_group_name VARCHAR(255);
ALTER TABLE orders ADD COLUMN table_order_index INTEGER;
ALTER TABLE orders ADD COLUMN is_merged BOOLEAN DEFAULT FALSE;
ALTER TABLE orders ADD COLUMN merged_from JSON;
ALTER TABLE orders ADD COLUMN can_be_merged BOOLEAN DEFAULT TRUE;
ALTER TABLE orders ADD COLUMN merge_restrictions JSON;
ALTER TABLE orders ADD COLUMN merge_history JSON;

2. CREATE ORDER_GROUPS TABLE
----------------------------
CREATE TABLE order_groups (
  id VARCHAR(255) PRIMARY KEY,
  table_id VARCHAR(255) NOT NULL,
  name VARCHAR(255) NOT NULL,
  customer_name VARCHAR(255),
  customer_phone VARCHAR(255),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (table_id) REFERENCES tables(id)
);

3. CREATE ORDER_MERGE_HISTORY TABLE
-----------------------------------
CREATE TABLE order_merge_history (
  id VARCHAR(255) PRIMARY KEY,
  merged_order_id VARCHAR(255) NOT NULL,
  source_order_id VARCHAR(255) NOT NULL,
  table_id VARCHAR(255) NOT NULL,
  merged_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  merged_by VARCHAR(255) NOT NULL,
  merge_reason TEXT,
  merge_strategy VARCHAR(50),
  customer_name_before VARCHAR(255),
  customer_name_after VARCHAR(255),
  total_amount_before DECIMAL(10,2),
  total_amount_after DECIMAL(10,2),
  FOREIGN KEY (merged_order_id) REFERENCES orders(id),
  FOREIGN KEY (source_order_id) REFERENCES orders(id),
  FOREIGN KEY (table_id) REFERENCES tables(id)
);

4. CREATE ORDER_SPLIT_HISTORY TABLE
-----------------------------------
CREATE TABLE order_split_history (
  id VARCHAR(255) PRIMARY KEY,
  original_order_id VARCHAR(255) NOT NULL,
  new_order_id VARCHAR(255) NOT NULL,
  table_id VARCHAR(255) NOT NULL,
  split_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  split_by VARCHAR(255) NOT NULL,
  split_reason TEXT,
  items_split JSON,
  FOREIGN KEY (original_order_id) REFERENCES orders(id),
  FOREIGN KEY (new_order_id) REFERENCES orders(id),
  FOREIGN KEY (table_id) REFERENCES tables(id)
);

API ENDPOINTS REQUIRED
======================

1. GET TABLE ORDERS
-------------------
GET /api/v1/orders/table/:tableId

Response:
{
  "success": true,
  "data": {
    "table": {
      "id": "table_123",
      "number": "5",
      "capacity": 4,
      "status": "occupied"
    },
    "orders": [
      {
        "id": "order_1",
        "orderNumber": "ORD-001",
        "customerName": "John Doe",
        "customerPhone": "+1234567890",
        "total": 25.50,
        "status": "active",
        "orderGroupId": "group_1",
        "orderGroupName": "Customer 1",
        "tableOrderIndex": 1,
        "canBeMerged": true,
        "mergeRestrictions": [],
        "items": [...]
      }
    ],
    "orderGroups": [
      {
        "id": "group_1",
        "name": "Customer 1",
        "orders": ["order_1"],
        "totalAmount": 25.50,
        "customerName": "John Doe"
      }
    ],
    "tableSummary": {
      "totalOrders": 3,
      "totalAmount": 76.25,
      "canMerge": true,
      "mergeRestrictions": []
    }
  }
}

2. MERGE ORDERS
---------------
POST /api/v1/orders/merge

Request:
{
  "sourceOrderIds": ["order_1", "order_2"],
  "targetOrderId": "order_3", // Optional: merge into existing order
  "mergeStrategy": "append", // "append" | "replace" | "create_new"
  "customerName": "John & Jane",
  "customerPhone": "+1234567890",
  "specialInstructions": "Combined order",
  "waiterId": "waiter_1",
  "waiterName": "Jane Smith",
  "tableId": "table_123",
  "createNewOrder": false
}

Response:
{
  "success": true,
  "data": {
    "mergedOrder": {
      "id": "order_merged_123",
      "orderNumber": "ORD-MERGED-001",
      "customerName": "John & Jane",
      "customerPhone": "+1234567890",
      "total": 44.25,
      "status": "active",
      "mergedFrom": ["order_1", "order_2"],
      "items": [...]
    },
    "sourceOrders": [...],
    "tableOrders": [...], // Updated list of all orders for table
    "mergeSummary": {
      "totalItems": 5,
      "totalAmount": 44.25,
      "itemCount": 3,
      "customerCount": 2,
      "ordersMerged": 2
    }
  }
}

3. SPLIT ORDER
--------------
POST /api/v1/orders/:orderId/split

Request:
{
  "splitItems": [
    {
      "itemId": "item_1",
      "quantity": 2,
      "newOrderCustomerName": "John Doe",
      "newOrderCustomerPhone": "+1234567890",
      "newOrderSpecialInstructions": "John's items"
    }
  ],
  "newOrderTableId": "table_123" // Optional: different table
}

Response:
{
  "success": true,
  "data": {
    "originalOrder": {...},
    "newOrders": [...],
    "splitSummary": {
      "originalOrderTotal": 25.50,
      "newOrdersTotal": 18.75,
      "totalItemsSplit": 2
    }
  }
}

4. GET MERGE HISTORY
--------------------
GET /api/v1/orders/:orderId/merge-history

Response:
{
  "success": true,
  "data": {
    "mergeHistory": [
      {
        "id": "merge_1",
        "mergedOrderId": "order_123",
        "sourceOrderId": "order_456",
        "mergedAt": "2024-01-15T10:30:00Z",
        "mergedBy": "waiter_1",
        "mergeReason": "Customer request",
        "mergeStrategy": "append"
      }
    ]
  }
}

5. VALIDATE MERGE
-----------------
POST /api/v1/orders/validate-merge

Request:
{
  "sourceOrderIds": ["order_1", "order_2"],
  "targetOrderId": "order_3"
}

Response:
{
  "success": true,
  "data": {
    "canMerge": true,
    "restrictions": [],
    "warnings": ["Different payment methods"],
    "preview": {
      "mergedOrder": {...},
      "totalAmount": 44.25,
      "itemCount": 5
    }
  }
}

BUSINESS LOGIC REQUIREMENTS
==========================

1. MERGE VALIDATION RULES
-------------------------
- Orders must be from the same table
- Orders must be in "active" status
- Orders must not be paid or cancelled
- Orders must not exceed maximum item limits (configurable)
- Orders must not have conflicting payment methods (warning only)
- Orders must not have conflicting customer information (warning only)
- Table must have capacity for merged order

2. ITEM CONFLICT RESOLUTION
---------------------------
- Same item, same notes: Sum quantities
- Same item, different notes: Keep separate with combined notes
- Different items: Append to target order
- Handle price changes during merge
- Preserve item history and timestamps

3. CUSTOMER INFORMATION MERGING
-------------------------------
- Combine customer names (e.g., "John & Jane")
- Merge phone numbers (keep primary, add secondary)
- Combine special instructions
- Preserve original customer info in merge history

4. PAYMENT METHOD HANDLING
--------------------------
- Allow different payment methods in same order
- Show warnings for payment conflicts
- Track payment method changes in merge history
- Support split payments after merge

5. AUDIT TRAIL REQUIREMENTS
---------------------------
- Log all merge operations with timestamps
- Track who performed the merge
- Record before/after states
- Store merge reasons and strategies
- Enable merge reversal (if needed)

ERROR HANDLING
==============

1. MERGE ERRORS
---------------
{
  "success": false,
  "error": {
    "code": "INVALID_ORDERS",
    "message": "One or more orders cannot be merged",
    "details": {
      "orderIds": ["order_1"],
      "restrictions": ["Order is already paid"]
    }
  }
}

2. VALIDATION ERRORS
--------------------
{
  "success": false,
  "error": {
    "code": "TABLE_MISMATCH",
    "message": "Orders must be from the same table",
    "details": {
      "tableIds": ["table_1", "table_2"]
    }
  }
}

3. CONFLICT ERRORS
------------------
{
  "success": false,
  "error": {
    "code": "PAYMENT_CONFLICT",
    "message": "Orders have conflicting payment methods",
    "details": {
      "paymentMethods": ["CASH", "CARD"]
    }
  }
}

CONFIGURATION OPTIONS
====================

1. MERGE SETTINGS
-----------------
- Maximum items per order (default: 50)
- Maximum orders per table (default: 10)
- Allow different payment methods (default: true)
- Require customer confirmation (default: true)
- Auto-generate order numbers for merged orders
- Default merge strategy (append/replace/create_new)

2. VALIDATION SETTINGS
----------------------
- Strict mode (prevent all conflicts)
- Warning mode (allow with warnings)
- Flexible mode (allow most merges)

3. AUDIT SETTINGS
-----------------
- Log all merge operations
- Store merge history retention period
- Enable merge reversal
- Track merge performance metrics

IMPLEMENTATION PRIORITY
======================

PHASE 1 (Core Functionality):
- Database schema updates
- GET /api/v1/orders/table/:tableId
- POST /api/v1/orders/merge (basic)
- POST /api/v1/orders/validate-merge
- Basic error handling

PHASE 2 (Advanced Features):
- POST /api/v1/orders/:orderId/split
- GET /api/v1/orders/:orderId/merge-history
- Enhanced customer information merging
- Payment method conflict resolution

PHASE 3 (Audit & Analytics):
- Comprehensive audit trail
- Merge performance metrics
- Merge reversal functionality
- Advanced configuration options

TESTING REQUIREMENTS
===================

1. UNIT TESTS
-------------
- Merge validation logic
- Item conflict resolution
- Customer information merging
- Payment method handling
- Error scenarios

2. INTEGRATION TESTS
--------------------
- End-to-end merge operations
- Database consistency
- API response validation
- Error handling scenarios

3. PERFORMANCE TESTS
--------------------
- Large order merging
- Multiple concurrent merges
- Database query optimization
- Memory usage optimization

SECURITY CONSIDERATIONS
======================

1. AUTHORIZATION
---------------
- Only authorized staff can perform merges
- Log all merge operations with user ID
- Validate user permissions before merge

2. DATA INTEGRITY
-----------------
- Prevent data corruption during merge
- Use database transactions for atomicity
- Validate data consistency after merge

3. AUDIT COMPLIANCE
-------------------
- Maintain complete audit trail
- Enable merge reversal for compliance
- Track all changes for reporting

DEPLOYMENT NOTES
================

1. DATABASE MIGRATION
---------------------
- Run schema updates during maintenance window
- Back up existing data before migration
- Test migration on staging environment

2. API VERSIONING
-----------------
- Use API versioning for backward compatibility
- Document breaking changes
- Provide migration guide for frontend

3. MONITORING
-------------
- Monitor merge operation performance
- Track error rates and types
- Alert on failed merge operations

This document provides all the requirements needed to implement the merge bills feature on the backend. The frontend team will need this functionality to build the user interface for merging orders. After this is done, please provide frontend with a .txt document of the api endpoints and the data structure of the response and what the frontend should do with the data.