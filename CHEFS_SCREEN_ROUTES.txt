===============================================================================
                    CHEFS SCREEN ROUTES GUIDE
                    All Routes, Data & Implementation
===============================================================================

BASE URL: https://your-domain.com/api

===============================================================================
                           AUTHENTICATION
===============================================================================

All routes require JWT token in header:
Authorization: Bearer <your-jwt-token>

Get token via: POST /api/login (OTP-based authentication)

===============================================================================
                           REQUIRED ROUTES
===============================================================================

1. GET ORDERS
--------------
GET /api/orders
Authorization: Bearer <token>

Query Parameters (optional):
- status: "active" | "closed" | "cancelled"
- tableId: string

Response:
{
  "success": true,
  "data": {
    "orders": [
      {
        "id": "order-uuid",
        "orderNumber": "ORD-001",
        "tableId": "table-uuid", 
        "tableNumber": "5",
        "items": [
          {
            "id": "item-uuid",
            "menuItemId": "menu-uuid",
            "menuItemName": "Burger",
            "quantity": 2,
            "price": 12.99,
            "total": 25.98,
            "notes": "No onions",
            "status": "pending" // Display only, not saved
          }
        ],
        "total": 25.98,
        "status": "active",
        "paymentStatus": "pending",
        "waiterId": "waiter-uuid",
        "waiterName": "John Doe",
        "orderSource": "QR_ORDERING",
        "customerName": "Jane Smith",
        "customerPhone": "+1234567890",
        "createdAt": "2024-01-01T10:00:00Z",
        "updatedAt": "2024-01-01T10:00:00Z"
      }
    ]
  }
}

2. GET TABLES
-------------
GET /api/tables
Authorization: Bearer <token>

Response:
{
  "tables": [
    {
      "id": "table-uuid",
      "number": "5",
      "capacity": 4,
      "status": "occupied",
      "locationId": "location-uuid"
    }
  ]
}

3. UPDATE ORDER STATUS
---------------------
PUT /api/orders/[id]
Authorization: Bearer <token>
Content-Type: application/json

Request Body:
{
  "status": "closed" | "cancelled"
}

Response:
{
  "success": true,
  "data": {
    "order": { /* Updated order object */ }
  }
}

===============================================================================
                           WEBSOCKET CONNECTION
===============================================================================

The system uses Socket.IO client, NOT raw WebSocket.

CONNECTION DETAILS:
- Library: Socket.IO client (import { io } from "socket.io-client")
- URL: Environment variable NEXT_PUBLIC_WEBSOCKET_URL or fallback to "http://localhost:5050"
- Protocol: HTTP/HTTPS (Socket.IO handles WebSocket upgrade)
- Authentication: JWT token sent via "authenticate" event after connection

IMPLEMENTATION:
```javascript
import { io } from "socket.io-client";

// 1. Connect to Socket.IO server
const socket = io(process.env.NEXT_PUBLIC_WEBSOCKET_URL || "http://localhost:5050", {
  transports: ["websocket", "polling"],
  autoConnect: true,
  reconnection: true,
  reconnectionAttempts: 3,
  reconnectionDelay: 1000,
  timeout: 10000
});

// 2. Authenticate with JWT token after connection
socket.on("connect", () => {
  console.log("Connected to WebSocket server");
  socket.emit("authenticate", { token: "your-jwt-token" });
});

// 3. Listen for authentication response
socket.on("authenticated", () => {
  console.log("WebSocket authenticated successfully");
});

socket.on("authentication_error", (error) => {
  console.warn("WebSocket authentication failed:", error);
});

// 4. Listen for order events
socket.on("newOrder", (data) => {
  console.log("New order received:", data);
  // Handle new order
});

socket.on("orderModified", (data) => {
  console.log("Order modified:", data);
  // Handle order modification
});
```

EVENTS:
- "connect" - Successfully connected
- "authenticated" - JWT authentication successful
- "authentication_error" - JWT authentication failed
- "newOrder" - New order received
- "orderModified" - Order modified

AUTHENTICATION FLOW:
1. Connect to Socket.IO server
2. Wait for "connect" event
3. Emit "authenticate" event with JWT token
4. Wait for "authenticated" or "authentication_error" event
5. Start listening for order events

===============================================================================
                           DATA CALCULATIONS
===============================================================================

1. WAIT TIME
-------------
```javascript
const waitTime = Math.floor((Date.now() - new Date(order.createdAt)) / 60000);
```

2. ORDER PROGRESS
-----------------
```javascript
const totalItems = order.items.length;
const readyItems = order.items.filter(item => 
  item.status === "ready" || item.status === "served"
).length;
const preparingItems = order.items.filter(item => 
  item.status === "preparing"
).length;

let progress = "pending";
if (readyItems === totalItems) progress = "ready";
else if (preparingItems > 0 || readyItems > 0) progress = "preparing";
```

3. URGENCY
----------
```javascript
const isUrgent = waitTime > 20; // 20+ minutes = urgent
```

4. CARD COLOR
-------------
```javascript
const getCardColor = () => {
  if (order.status === "closed") return "bg-gray-50";
  if (progress === "ready") return "bg-green-50";
  if (isUrgent) return "bg-red-50";
  if (waitTime > 15) return "bg-yellow-50";
  return "bg-white";
};
```

===============================================================================
                           IMPLEMENTATION FLOW
===============================================================================

1. APP STARTUP
--------------
```javascript
// 1. Authenticate and get token
const token = await login(email, otp);

// 2. Connect WebSocket
const socket = io('https://your-domain.com', { auth: { token } });

// 3. Fetch initial data
const orders = await fetchOrders(token);
const tables = await fetchTables(token);

// 4. Set up real-time listeners
socket.on('newOrder', handleNewOrder);
socket.on('orderModified', handleOrderModified);
```

2. ORDER DISPLAY
----------------
```javascript
// Map table IDs to table numbers
const getTableName = (tableId) => {
  const table = tables.find(t => t.id === tableId);
  return table ? table.number : tableId;
};

// Calculate progress for each order
const getOrderProgress = (order) => {
  // ... progress calculation logic
};

// Filter orders by progress
const filterOrders = (orders, filter) => {
  if (filter === "all") return orders;
  return orders.filter(order => getOrderProgress(order) === filter);
};
```

3. ORDER ACTIONS
----------------
```javascript
// Complete order
const completeOrder = async (orderId) => {
  await fetch(`/api/orders/${orderId}`, {
    method: 'PUT',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ status: 'closed' })
  });
  
  // Refresh orders
  await fetchOrders(token);
};

// Cancel order
const cancelOrder = async (orderId) => {
  await fetch(`/api/orders/${orderId}`, {
    method: 'PUT',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ status: 'cancelled' })
  });
  
  await fetchOrders(token);
};
```

4. REAL-TIME UPDATES
--------------------
```javascript
// Handle new orders
socket.on('newOrder', (data) => {
  // Add to orders list
  setOrders(prev => [data.order, ...prev]);
  
  // Show notification
  showNotification(data.order);
  
  // Play sound
  playNotificationSound();
});

// Handle order modifications
socket.on('orderModified', (data) => {
  // Update existing order
  setOrders(prev => prev.map(order => 
    order.id === data.order.id ? data.order : order
  ));
  
  // Show modification notification
  showModificationNotification(data.order, data.changes);
});
```

5. FILTERING & SORTING
----------------------
```javascript
// Filter tabs
const filterTabs = [
  { id: "all", label: "All Orders", count: orders.length },
  { id: "new", label: "New", count: orders.filter(o => getOrderProgress(o) === "new").length },
  { id: "preparing", label: "Preparing", count: orders.filter(o => getOrderProgress(o) === "preparing").length },
  { id: "ready", label: "Ready", count: orders.filter(o => getOrderProgress(o) === "ready").length }
];

// Sort orders (oldest first for kitchen)
const sortedOrders = orders.sort((a, b) => 
  new Date(a.createdAt) - new Date(b.createdAt)
);
```

===============================================================================
                           POLLING FOR UPDATES
===============================================================================

If WebSocket fails, fallback to polling:
```javascript
// Poll every 30 seconds
const pollInterval = setInterval(() => {
  fetchOrders(token);
}, 30000);

// Clean up on unmount
return () => clearInterval(pollInterval);
```

===============================================================================
                           ERROR HANDLING
===============================================================================

```javascript
try {
  const response = await fetch('/api/orders', {
    headers: { 'Authorization': `Bearer ${token}` }
  });
  
  if (!response.ok) {
    if (response.status === 401) {
      // Token expired, refresh or re-login
      await refreshToken();
    } else {
      throw new Error(`HTTP ${response.status}`);
    }
  }
  
  const data = await response.json();
  return data;
} catch (error) {
  console.error('Failed to fetch orders:', error);
  // Show user-friendly error message
  showError('Failed to load orders. Please try again.');
}
```

===============================================================================
                           NOTIFICATION SYSTEM
===============================================================================

The system handles real-time order notifications through a comprehensive notification manager.

===============================================================================
                           WEBSOCKET NOTIFICATION EVENTS
===============================================================================

The system listens for 2 main WebSocket events:

1. "newOrder" EVENT
-------------------
Trigger: New order received from backend
Data Type: "PRINT_RECEIPT"
Data Structure:
```javascript
{
  type: "PRINT_RECEIPT",
  order: { /* OrderData object */ },
  timestamp: "2024-01-01T10:00:00Z",
  notificationId: "unique-notification-id"
}
```

2. "orderModified" EVENT
------------------------
Trigger: Existing order was modified
Data Type: "PRINT_MODIFIED_RECEIPT"
Data Structure:
```javascript
{
  type: "PRINT_MODIFIED_RECEIPT",
  order: { /* OrderData object */ },
  changes: {
    addedItems: [...],
    removedItems: [...],
    modifiedItems: [...],
    modificationType: "add" | "remove" | "modify" | "mixed",
    modifiedBy: "user-id"
  },
  timestamp: "2024-01-01T10:00:00Z",
  notificationId: "unique-notification-id"
}
```

===============================================================================
                           WHAT HAPPENS WHEN NOTIFICATIONS ARE RECEIVED
===============================================================================

1. NEW ORDER NOTIFICATION PROCESSING
-----------------------------------
```javascript
// 1. Validate notification ID
if (!notificationId) return;

// 2. Check for duplicate processing
if (isNotificationProcessed(notificationId)) return;

// 3. Mark as processed immediately
markNotificationAsProcessed(notificationId);

// 4. Create notification object
const notification = {
  id: `notification_${Date.now()}_${randomId}`,
  order: mappedOrderData,
  timestamp: new Date().toISOString(),
  isRead: false
};

// 5. Add to notifications array
addNotification(notification);

// 6. Trigger callback for UI updates
if (onNotificationCallback) {
  onNotificationCallback(notification);
}

// 7. Show browser notification
showBrowserNotification(mappedOrderData);

// 8. Print receipt automatically
await printReceipt(mappedOrderData);
```

2. MODIFIED ORDER NOTIFICATION PROCESSING
----------------------------------------
```javascript
// 1. Validate changes object and notification ID
if (!changes || !notificationId) return;

// 2. Check for duplicate processing
if (isNotificationProcessed(notificationId)) return;

// 3. Mark as processed immediately
markNotificationAsProcessed(notificationId);

// 4. Create notification with changes
const notification = {
  id: `notification_${Date.now()}_${randomId}`,
  order: mappedOrderData,
  timestamp: new Date().toISOString(),
  isRead: false,
  changes: changes // Include modification details
};

// 5. Add to notifications array
addNotification(notification);

// 6. Trigger callback for UI updates
if (onNotificationCallback) {
  onNotificationCallback(notification);
}

// 7. Show modified order browser notification
showModifiedBrowserNotification(mappedOrderData, changes);

// 8. Print updated receipt
await printReceipt(mappedOrderData, changes);
```

===============================================================================
                           NOTIFICATION MANAGER SYSTEM
===============================================================================

The NotificationManager is a React component that handles the display and lifecycle of notifications.

1. NOTIFICATION QUEUE MANAGEMENT
--------------------------------
```javascript
// State management
const [currentNotification, setCurrentNotification] = useState(null);
const [notificationQueue, setNotificationQueue] = useState([]);
const [isShowing, setIsShowing] = useState(false);

// Handle new notifications
useEffect(() => {
  if (notifications.length > 0) {
    const unreadNotifications = notifications.filter(n => !n.isRead);
    
    if (unreadNotifications.length > 0) {
      const latestUnreadNotification = unreadNotifications[0];
      
      if (!isShowing && !currentNotification) {
        // Show the latest unread notification
        setCurrentNotification(latestUnreadNotification);
        setIsShowing(true);
      } else if (isShowing && currentNotification) {
        // Add to queue if another notification is already showing
        setNotificationQueue(prev => [...prev, latestUnreadNotification]);
      }
    }
  }
}, [notifications, isShowing, currentNotification]);
```

2. NOTIFICATION DISPLAY LOGIC
-----------------------------
- Only shows unread notifications
- Queues notifications if one is already displaying
- Shows next notification after current one closes
- Prevents notification spam

3. NOTIFICATION LIFECYCLE
-------------------------
```javascript
// Show notification
setCurrentNotification(notification);
setIsShowing(true);

// Auto-hide after 10 seconds
setTimeout(() => {
  setIsVisible(false);
  setTimeout(onClose, 300); // Wait for animation
}, 10000);

// Mark as read
const handleMarkAsRead = (id) => {
  onMarkAsRead(id);
  setIsShowing(false);
  setCurrentNotification(null);
  
  // Clear queue for this notification ID
  setNotificationQueue(prev => prev.filter(n => n.id !== id));
};
```

===============================================================================
                           NOTIFICATION POPUP COMPONENT
===============================================================================

The OrderNotificationPopup displays individual notifications with different styles for new vs modified orders.

1. VISUAL DIFFERENCES
---------------------
- **New Order**: Green header with "New Order Received!"
- **Modified Order**: Blue header with "Order Modified!"

2. CONTENT DISPLAY
------------------
- Order number and table
- Customer information (name, phone)
- Waiter/source details
- Item list with quantities and prices
- Special instructions/notes
- Total amount
- Time since notification

3. MODIFICATION DETAILS
-----------------------
For modified orders, shows:
- Added items (green)
- Removed items (red)
- Modified items (orange)
- Who made the changes

4. AUTO-DISMISS
---------------
- Shows for 10 seconds
- Fades out with animation
- Can be manually dismissed

===============================================================================
                           DUPLICATE PREVENTION
===============================================================================

The system prevents duplicate notifications using:

1. NOTIFICATION ID TRACKING
---------------------------
```javascript
// Track processed notification IDs with timestamps
private processedNotificationIds: Map<string, number> = new Map();

// Check if already processed
private isNotificationProcessed(notificationId: string): boolean {
  const processedTime = this.processedNotificationIds.get(notificationId);
  if (!processedTime) return false;

  const timeSinceProcessed = Date.now() - processedTime;
  const isRecentlyProcessed = timeSinceProcessed < 10 * 1000; // 10 seconds

  return isRecentlyProcessed;
}
```

2. IMMEDIATE MARKING
--------------------
- Notifications are marked as processed immediately upon receipt
- Prevents race conditions and duplicate processing
- 10-second window for duplicate prevention

3. CLEANUP
-----------
- Old notification IDs are cleaned up after 1 hour
- Prevents memory leaks from long-running sessions

===============================================================================
                           BROWSER NOTIFICATIONS
===============================================================================

The system also shows native browser notifications:

1. PERMISSION REQUEST
---------------------
```javascript
useEffect(() => {
  if ('Notification' in window && Notification.permission === 'default') {
    Notification.requestPermission();
  }
}, []);
```

2. NOTIFICATION DISPLAY
-----------------------
```javascript
// New order notification
showBrowserNotification(orderData);

// Modified order notification  
showModifiedBrowserNotification(orderData, changes);
```

3. NOTIFICATION CONTENT
-----------------------
- Title: "New Order" or "Order Modified"
- Body: Order details and table number
- Icon: System default or custom icon

===============================================================================
                           SOUND NOTIFICATIONS
===============================================================================

Audio notifications are generated using Web Audio API:

1. SOUND GENERATION
-------------------
```javascript
// Create notification sound
const audioContext = new AudioContext();
const oscillator = audioContext.createOscillator();
const gainNode = audioContext.createGain();

oscillator.connect(gainNode);
gainNode.connect(audioContext.destination);

// Frequency pattern: 800Hz → 600Hz → 800Hz
oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.1);
oscillator.frequency.setValueAtTime(800, audioContext.currentTime + 0.2);

// Play for 0.3 seconds
oscillator.start(audioContext.currentTime);
oscillator.stop(audioContext.currentTime + 0.3);
```

2. TRIGGER CONDITIONS
---------------------
- Plays when new unread notifications arrive
- Only if user has permission to receive print notifications
- Volume controlled at 30% to avoid startling users

===============================================================================
                           NOTIFICATION INTEGRATION FLOW
===============================================================================

Complete flow from WebSocket to UI:

1. **WebSocket Event Received**
   - "newOrder" or "orderModified" event
   - Data validated and processed

2. **Notification Created**
   - OrderNotification object created
   - Added to notifications array
   - Marked as processed to prevent duplicates

3. **Callback Triggered**
   - onNotificationCallback executed
   - UI components updated with new notification

4. **Visual Display**
   - NotificationManager shows popup
   - Browser notification displayed
   - Sound played

5. **Receipt Printing**
   - Automatic receipt generation
   - Sent to PrintBridge for printing

6. **User Interaction**
   - User can mark as read
   - Notification dismissed
   - Next notification in queue shown

===============================================================================
                           SUMMARY
===============================================================================

The notification system provides:

✅ **Real-time Updates**: WebSocket events for new/modified orders
✅ **Duplicate Prevention**: Notification ID tracking and processing
✅ **Queue Management**: Smart notification queuing and display
✅ **Multiple Channels**: Popup, browser, and sound notifications
✅ **Automatic Actions**: Receipt printing and UI updates
✅ **User Control**: Mark as read, dismiss, and queue management

The system ensures kitchen staff are immediately notified of new orders and modifications, with automatic receipt printing and intelligent notification management to prevent spam while maintaining visibility of all important updates.

===============================================================================

