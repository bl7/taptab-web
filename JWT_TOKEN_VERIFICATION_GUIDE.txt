JWT TOKEN VERIFICATION GUIDE
================================

OVERVIEW
--------
This guide explains how external backends can verify JWT tokens generated by the TapTab authentication system.

TOKEN STRUCTURE
---------------
JWT tokens contain the following payload:

{
  "id": "user-uuid",
  "email": "user@example.com", 
  "role": "TENANT_ADMIN",
  "tenantId": "tenant-uuid",
  "iat": 1234567890,
  "exp": 1234567890
}

AVAILABLE ROLES
---------------
- SUPER_ADMIN: Full system access
- TENANT_ADMIN: Restaurant owner/admin
- MANAGER: Restaurant manager
- CASHIER: Cashier/order taker
- WAITER: Server/waitstaff
- KITCHEN: Kitchen staff
- READONLY: Read-only access

VERIFICATION STEPS
------------------

1. TOKEN EXTRACTION
   Extract token from Authorization header:
   const token = req.headers.authorization?.replace('Bearer ', '');

2. SIGNATURE VERIFICATION
   Verify token signature using JWT_SECRET:
   const decoded = jwt.verify(token, JWT_SECRET);

3. EXPIRATION CHECK
   Check if token is expired:
   if (Date.now() >= decoded.exp * 1000) {
     throw new Error('Token expired');
   }

4. USER STATUS VERIFICATION
   Verify user exists and is active:
   const user = await db.query(
     'SELECT * FROM users WHERE id = $1 AND "isActive" = true', 
     [decoded.id]
   );
   if (!user) throw new Error('User not found or inactive');

5. ROLE-BASED AUTHORIZATION
   Check if user has required role:
   const requiredRoles = ['SUPER_ADMIN', 'TENANT_ADMIN'];
   if (!requiredRoles.includes(decoded.role)) {
     throw new Error('Insufficient permissions');
   }

6. TENANT ACCESS CONTROL
   For tenant-specific operations:
   if (decoded.role !== 'SUPER_ADMIN' && decoded.tenantId !== targetTenantId) {
     throw new Error('Access denied to this tenant');
   }

EXPRESS.JS MIDDLEWARE EXAMPLES
------------------------------

Basic Authentication Middleware:
```javascript
const jwt = require('jsonwebtoken');

const authMiddleware = async (req, res, next) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');
    if (!token) {
      return res.status(401).json({ error: 'No token provided' });
    }
    
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // Verify user exists and is active
    const user = await db.query(
      'SELECT * FROM users WHERE id = $1 AND "isActive" = true',
      [decoded.id]
    );
    
    if (!user.rows[0]) {
      return res.status(401).json({ error: 'User not found or inactive' });
    }
    
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Invalid token' });
  }
};
```

Role-Based Authorization:
```javascript
const requireRole = (roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }
    next();
  };
};

// Usage
app.get('/api/admin', authMiddleware, requireRole(['SUPER_ADMIN']), (req, res) => {
  // Super admin only route
});

app.get('/api/restaurant', authMiddleware, requireRole(['TENANT_ADMIN', 'MANAGER']), (req, res) => {
  // Restaurant admin/manager route
});
```

Tenant Access Control:
```javascript
const requireTenantAccess = (req, res, next) => {
  const targetTenantId = req.params.tenantId || req.body.tenantId;
  
  if (req.user.role === 'SUPER_ADMIN') {
    return next(); // Super admin can access all tenants
  }
  
  if (req.user.tenantId !== targetTenantId) {
    return res.status(403).json({ error: 'Access denied to this tenant' });
  }
  
  next();
};
```

NODE.JS EXAMPLE
---------------

```javascript
const jwt = require('jsonwebtoken');
const { Pool } = require('pg');

const pool = new Pool({
  // Your database configuration
});

const verifyToken = async (token) => {
  try {
    // 1. Verify signature and expiration
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // 2. Check if token is blacklisted (if you implement blacklisting)
    // const isBlacklisted = await checkTokenBlacklist(token);
    // if (isBlacklisted) throw new Error('Token is blacklisted');
    
    // 3. Verify user exists and is active
    const userResult = await pool.query(
      'SELECT * FROM users WHERE id = $1 AND "isActive" = true',
      [decoded.id]
    );
    
    if (!userResult.rows[0]) {
      throw new Error('User not found or inactive');
    }
    
    return decoded;
  } catch (error) {
    throw new Error('Invalid token');
  }
};

const hasRole = (user, roles) => {
  return roles.includes(user.role);
};

const canAccessTenant = (user, tenantId) => {
  return user.role === 'SUPER_ADMIN' || user.tenantId === tenantId;
};

// Usage in route
app.get('/api/users', async (req, res) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');
    const user = await verifyToken(token);
    
    // Check permissions
    if (!hasRole(user, ['SUPER_ADMIN', 'TENANT_ADMIN'])) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }
    
    // Get users based on role
    let query = 'SELECT * FROM users';
    let params = [];
    
    if (user.role !== 'SUPER_ADMIN') {
      query += ' WHERE "tenantId" = $1';
      params.push(user.tenantId);
    }
    
    const result = await pool.query(query, params);
    res.json({ users: result.rows });
  } catch (error) {
    res.status(401).json({ error: error.message });
  }
});
```

PYTHON EXAMPLE
--------------

```python
import jwt
import psycopg2
from functools import wraps
from flask import request, jsonify

def verify_token(token):
    try:
        # 1. Verify signature and expiration
        decoded = jwt.decode(token, JWT_SECRET, algorithms=['HS256'])
        
        # 2. Verify user exists and is active
        conn = psycopg2.connect(DATABASE_URL)
        cursor = conn.cursor()
        cursor.execute(
            "SELECT * FROM users WHERE id = %s AND \"isActive\" = true",
            (decoded['id'],)
        )
        user = cursor.fetchone()
        
        if not user:
            raise Exception('User not found or inactive')
        
        cursor.close()
        conn.close()
        
        return decoded
    except Exception as e:
        raise Exception('Invalid token')

def require_role(roles):
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            token = request.headers.get('Authorization', '').replace('Bearer ', '')
            user = verify_token(token)
            
            if user['role'] not in roles:
                return jsonify({'error': 'Insufficient permissions'}), 403
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator

# Usage
@app.route('/api/admin')
@require_role(['SUPER_ADMIN'])
def admin_route():
    return jsonify({'message': 'Admin access granted'})
```

SECURITY CONSIDERATIONS
----------------------

1. ALWAYS verify token signature with the correct JWT_SECRET
2. ALWAYS check token expiration
3. ALWAYS verify user exists and is active in database
4. Implement token blacklisting for logout functionality
5. Use HTTPS in production
6. Store JWT_SECRET securely
7. Consider implementing refresh tokens for better security
8. Log authentication attempts for security monitoring

ERROR HANDLING
--------------

Common error responses:
- 401 Unauthorized: Invalid or missing token
- 403 Forbidden: Insufficient permissions
- 400 Bad Request: Malformed token

EXAMPLE ERROR RESPONSES:
```json
{
  "error": "No token provided"
}

{
  "error": "Token expired"
}

{
  "error": "User not found or inactive"
}

{
  "error": "Insufficient permissions"
}

{
  "error": "Access denied to this tenant"
}
```

ENVIRONMENT VARIABLES
--------------------
Make sure to set these in your backend:
- JWT_SECRET: The same secret used by TapTab for signing tokens
- DATABASE_URL: Your PostgreSQL connection string

TESTING
-------
Test your token verification with:
1. Valid token from TapTab login
2. Expired token
3. Invalid signature
4. Missing token
5. User with different roles
6. Inactive user

This guide should help you implement secure token verification in your external backend systems. 